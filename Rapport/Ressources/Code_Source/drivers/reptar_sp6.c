/*******************************************************************
 * reptar_sp6.c
 *
 * Author: Romain Bornet (RBO), Daniel Rossier (DRE)
 * Copyright (c) 2013 HEIG-VD, REDS Institute
 *******************************************************************/

#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/firmware.h>
#include <linux/interrupt.h>
#include <linux/input.h>
#include <linux/string.h>

#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <linux/platform_device.h>
#include <linux/gpio.h>

#include <asm/uaccess.h>

#include "reptar_sp6.h"

#define FPGA_BASE 0x18000000

/* BOARD SPECIFIC CODE */
static struct resource fpga_resources[] = {
		{ .name = "fpga", .start = FPGA_BASE, .end = FPGA_BASE + 0xffff,
				.flags = IORESOURCE_MEM }, { .name = "fpga_irq_gpio", .start =
				10, .end = 10, .flags = IORESOURCE_IRQ } };

/* Additional platform data related to FPGA */
struct fpga_platform_data {
	struct class *fpga_class;
} fpga_pdata;

static struct platform_device *fpga;

/* LEDS */
struct reptar_sp6_led_platdata reptar_sp6_leds_pdata[] = { { .name = "sp6_led0",
		.bit = 0, .reg_offset = 0x3a }, { .name = "sp6_led1", .bit = 1,
		.reg_offset = 0x3a },
		{ .name = "sp6_led2", .bit = 2, .reg_offset = 0x3a }, { .name =
				"sp6_led3", .bit = 3, .reg_offset = 0x3a }, {
				.name = "sp6_led4", .bit = 4, .reg_offset = 0x3a }, { .name =
				"sp6_led5", .bit = 5, .reg_offset = 0x3a }, };

/* Buttons */
struct reptar_sp6_buttons_platdata reptar_sp6_btns_pdata = { .btns_reg_offset =
		0x12, .irq_reg_offset = 0x18,

/* Key codes generated by buttons 0 --> 7 */
.keys = { KEY_UP, KEY_LEFT, KEY_DOWN, KEY_RIGHT, KEY_ENTER, KEY_ESC, KEY_SPACE,
KEY_BACKSPACE }, };

/* < END OF BOARD SPECIFIC CODE > */

/* FPGA Bitstream version */
#define MAX_LENGTH 80
static char bitstream_version[MAX_LENGTH] = "FPGA bitstream VERSION";

/* Callbacks for char device */

ssize_t fpga_read(struct file *filp, char *buffer, size_t length,
		loff_t *offset) {

	/* If offset is not zero, it means that a previous read already occured.
	 * So, we tell the user space that we are at the end
	 */
//	if (*offset != 0) //what ???
//		return 0;
	/* to be completed */
	int notreLen = strnlen(bitstream_version, MAX_LENGTH);
	notreLen -= *offset;

	if (notreLen <= 0)
		return 0;

	if (length < notreLen) {
		notreLen = length;
	}

	copy_to_user(buffer, bitstream_version + *offset, notreLen);

	*offset += notreLen;
	return notreLen;
}

ssize_t fpga_write(struct file *filp, const char *buff, size_t len, loff_t *off) {

	/* to be completed */
	int nbytes; /* Number of bytes written */
	int bytes_to_do; /* Number of bytes to write */
	int maxbytes; /* Maximum number of bytes that can be written */

	maxbytes = (MAX_LENGTH - 1) - *off;

	if (maxbytes > len)
		bytes_to_do = len;
	else
		bytes_to_do = maxbytes;

	if (bytes_to_do == 0)

	{
		printk("Reached end of device\n");
		return -28; /* Returns EOF at write() */
	}

	//printk(KERN_DEBUG "bytes_to_do : %u",bytes_to_do);
	nbytes = bytes_to_do
			- copy_from_user(bitstream_version + *off, /* to */buff, /* from */
			bytes_to_do); /* how many bytes */
	*off += nbytes;
	//printk(KERN_DEBUG "offset : %llu",*off);
	bitstream_version[*off] = '\0';

	return nbytes;
}

loff_t fpga_seek(struct file *filp, loff_t offset, int orig) {

	loff_t new_pos = 0;

	switch (orig) {
	case 0: /* SEEK_SET: */
		new_pos = offset;
		break;
	case 1: /* SEEK_CUR: */
		new_pos = filp->f_pos + offset;
		break;
	case 2: /* SEEK_END: */
		new_pos = 80 - offset;
		break;
	}

	if (new_pos > 80)
		new_pos = 80;

	if (new_pos < 0)
		new_pos = 0;

	filp->f_pos = new_pos;

	return new_pos;
}

struct file_operations fpga_fops = { .read = fpga_read, .write = fpga_write,
		.llseek = fpga_seek };

/* FPGA driver probe */
static int fpga_probe(struct platform_device *pdev) {
	int ret;
	struct fpga_platform_data *pdata;
	struct cdev *fpga_cdev;

	printk("Probing FPGA driver (device: %s)\n", pdev->name);

	pdata = pdev->dev.platform_data;

	/* Nice to use platform_data in dev field to transport private info...*/
	pdata->fpga_class = class_create(THIS_MODULE, "fpga");

	/* character device ... */
	ret = alloc_chrdev_region(&pdev->dev.devt, 0, 1, "fpga");
	if (ret) {
		printk("%s alloc_chrdev failed!\n", __FUNCTION__);
		return -1;
	}

	fpga_cdev = cdev_alloc();

	/* We store the newly allocated cdev as a private driver data to this device */
	dev_set_drvdata(&pdev->dev, fpga_cdev);

	/* Initializing character device to enable user space ops */
	cdev_init(fpga_cdev, &fpga_fops);
	cdev_add(fpga_cdev, pdev->dev.devt, 1);

	device_create(pdata->fpga_class, NULL, pdev->dev.devt, NULL, "sp6");

	return 0;
}

static int fpga_remove(struct platform_device *pdev) {
	struct fpga_platform_data *pdata;
	struct cdev *fpga_cdev;

	fpga_cdev = dev_get_drvdata(&pdev->dev);
	pdata = pdev->dev.platform_data;

	cdev_del(fpga_cdev);
	device_destroy(pdata->fpga_class, pdev->dev.devt);
	unregister_chrdev_region(pdev->dev.devt, 1);

	return 0;
}

static struct platform_driver fpga_drv = { .probe = fpga_probe, .remove =
		fpga_remove, .driver = { .name = "fpga", .owner = THIS_MODULE, }, };

static int __devinit reptar_sp6_init(void) {

	int ret;

	printk("reptar_sp6: module starting...\n");

	fpga = platform_device_alloc("fpga", -1);

	if (!fpga) {
		printk("%s failed to alloc platform device\n", __FUNCTION__);
		return -ENOMEM;
	}

	ret = platform_device_add_resources(fpga, fpga_resources, ARRAY_SIZE(fpga_resources));

	if (ret) {
		printk("%s failed to add resources to platform device\n", __FUNCTION__);
		return -ENOMEM;
	}

	ret = platform_device_add_data(fpga, &fpga_pdata, sizeof(fpga_pdata));

	if (ret) {
		printk("%s failed to add data to platform device\n", __FUNCTION__);
		return -ENOMEM;
	}

	ret = platform_device_add(fpga);

	if (ret) {
		printk("%s failed to add data to platform device\n", __FUNCTION__);
		return -ENOMEM;
	}

	platform_driver_register(&fpga_drv);

	reptar_sp6_leds_init(fpga);
	reptar_sp6_buttons_init(fpga);

	printk("reptar_sp6: done.\n");

	return 0;
}

static void __exit reptar_sp6_exit(void) {

	struct fpga_platform_data *pdata;
	pdata = fpga->dev.platform_data;

	reptar_sp6_buttons_exit();
	reptar_sp6_leds_exit();

	platform_device_unregister(fpga);
	class_destroy(pdata->fpga_class);
	platform_driver_unregister(&fpga_drv);

	printk("reptar_sp6: bye bye!\n");
}

module_init( reptar_sp6_init);
module_exit( reptar_sp6_exit);

MODULE_LICENSE("GPL");
